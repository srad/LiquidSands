package de.frankfurt.uni.vcp.units;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.jme3.collision.CollisionResults;
import com.jme3.math.Ray;
import com.jme3.math.Vector3f;
import com.jme3.scene.Geometry;
import com.jme3.scene.Node;

import de.frankfurt.uni.vcp.enums.PlayerStates;
import de.frankfurt.uni.vcp.net.ProtocolError;
import de.frankfurt.uni.vcp.net.StatusError;
import de.frankfurt.uni.vcp.nodes.Field;
import de.frankfurt.uni.vcp.nodes.movables.Movable;

public class Player extends Node {

	/**
	 * all the units of a player. what more can i say?
	 */
	public List<Movable> units = new ArrayList<Movable>();
	
	public String playerName;
	
	/**
	 * An ID generated by the server to distinguish the players
	 */
	public String playerId;
	
	/**
	 * number of player joined to the game.
	 * used to assign a predefined color to a player
	 */
	public int number = 0;

	/**
	 * constructor setting an id
	 */
	public Player(String name, String playerId) {
	    this.playerName = name;
		this.playerId = playerId;
	}
	
	/**
	 * This method adds a unit to a player specified by the server when starting the game
	 * @param field where to place a single unit
	 * @param info which kind of unit to be placed
	 */
	public void addUnit(Field field, Movable unit) {

		units.add(unit);
		this.attachChild(unit);
		unit.setLocalTranslation((field.getLocalTranslation()));
		
		field.unit=unit;
		
	}
	
//	public void fixUnitsPosition(){
//		for(Movable unit : units)
//			unit.setLocalTranslation((unit.getField().getLocalTranslation()));
//		
//	}

	/**
	 * This method determines a scene object, intersected by the given ray.
	 * 
	 * @param position
	 *            starting point of the ray
	 * @param direction
	 *            of the ray
	 * @return the determined scene object
	 */
	public Movable pick(Vector3f position, Vector3f direction) {
		CollisionResults results = new CollisionResults();
		Ray ray = new Ray(position, direction);

		this.collideWith(ray, results);
		if (results.size() == 0) {
			return null;
		}

		Geometry geometry = results.getCollision(0).getGeometry();
		Movable unit = (Movable) geometry.getParent().getParent();

		return unit;
	}

	/**
	 * 
	 * @return a list of units belonging to a player which have not yet been
	 *         moved in the actual round
	 */
	public List<Movable> getActiveUnits() {
		List<Movable> u = new ArrayList<Movable>();
		for (Movable m : units) {
			if (m.getState().equals(PlayerStates.START)) {
				u.add(m);
			}
		}
		return u;
	}

	/**
	 * 
	 * @return whether a player has got units yet to move
	 */
	public boolean hasAnyActiveUnits() {
		return (getActiveUnits().size() > 0);
	}

	/**
	 * This method updates all information of all units retrieved from the server.
	 * updateStats() communicates with the server.
	 * @throws IOException
	 * @throws StatusError
	 * @throws ProtocolError
	 */
	public void refreshUnits() throws IOException, StatusError, ProtocolError {
		for (Movable m : units) {
			m.updateStats();
			m.setState(PlayerStates.START);
		}
	}

	@Override
	public String toString() {
		return "<Player: " + playerName + " number: " + number + " id: " + playerId + ">";
	}

}
